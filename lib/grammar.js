/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#496c3de8f0fffd0a7ee2b6e68e8c6e53dd7db0d7
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _initProto;
import { i } from '@bablr/boot';
import { CoveredBy, Node, InjectFrom } from '@bablr/helpers/decorators';
import * as productions from '@bablr/helpers/productions';
import * as CSTML from '@bablr/language-cstml';
import * as CSTMLInstruction from '@bablr/language-bablr-vm-instruction/cstml';
import * as SpamexInstruction from '@bablr/language-bablr-vm-instruction/spamex';
import * as Space from '@bablr/language-blank-space';
export const dependencies = {
  Space,
  CSTML,
  CSTMLInstruction,
  SpamexInstruction
};
export const canonicalURL = 'https://bablr.org/languages/core/bablr-cli-verbose-output';
export function* eatMatchTrivia() {
  if (yield i`match(/[ \t\n]/)`) {
    return yield i`eat(<#*Space:Space>)`;
  }
  return null;
}
export const grammar = (_dec = CoveredBy('Line'), _dec2 = CoveredBy('Line'), _dec3 = CoveredBy('Line'), _dec4 = CoveredBy('Line'), _dec5 = CoveredBy('Line'), _dec6 = CoveredBy('Line'), _dec7 = InjectFrom(productions), _dec8 = InjectFrom(productions), class VerboseOutputGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Output"], [[_dec, Node], 2, "EnterProductionLine"], [[_dec2, Node], 2, "LeaveProductionLine"], [[_dec3, Node], 2, "EmitLine"], [[_dec4, Node], 2, "ExecCSTMLInstructionLine"], [[_dec5, Node], 2, "ExecSpamexInstructionLine"], [[_dec6, Node], 2, "OutputLine"], [Node, 2, "Identifier"], [[Node, _dec7], 2, "Punctuator"], [_dec8, 2, "Any"]], []).e;
  }
  constructor(...args) {
    _initProto(this);
  }
  *Output() {
    while ((yield i`match(/./)`) && (yield i`eat(<Line> 'lines[]')`));
  }
  *Line() {
    yield i`eat(<Any> null [
      <ExecSpamexInstructionLine '>>>'>
      <ExecCSTMLInstructionLine '    >>>'>
      <EmitLine '<<<'>
      <EnterProductionLine '-->'>
      <LeaveProductionLine /[x<]--/>
      <OutputLine>
    ])`;
  }
  *EnterProductionLine() {
    yield i`eat(<~*Punctuator '-->'> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<*Identifier> 'productionName')`;
    yield i`eat(<~*Punctuator '\n'> 'lineTerminatorToken')`;
  }
  *LeaveProductionLine() {
    yield i`eat(<~*Punctuator /[<x]--/> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<*Identifier> 'productionName')`;
    yield i`eat(<~*Punctuator '\n'> 'lineTerminatorToken')`;
  }
  *EmitLine() {
    yield i`eat(<~*Punctuator '<<<'> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<CSTML:Token> 'expression')`;
    yield i`eat(<~*Punctuator '\n'> 'lineTerminatorToken')`;
  }
  *ExecCSTMLInstructionLine() {
    yield i`eat(<~*Punctuator '    >>>'> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<CSTMLInstruction:Call> 'instruction')`;
    yield i`eat(<~*Punctuator '\n'> 'lineTerminatorToken')`;
  }
  *ExecSpamexInstructionLine() {
    yield i`eat(<~*Punctuator '>>>'> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<SpamexInstruction:Call> 'instruction')`;
    yield i`eat(<~*Punctuator '\n'> 'lineTerminatorToken')`;
  }
  *OutputLine() {
    yield* eatMatchTrivia();
    yield i`eat(<CSTML:Token> 'expression')`;
    yield i`eat(<~*Punctuator '\n'> 'lineTerminatorToken')`;
  }
  *Identifier() {
    yield i`eat(/[a-zA-Z]+/)`;
  }
  *Punctuator() {}
  *Any() {}
});