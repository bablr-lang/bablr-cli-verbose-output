/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#670b2ea0703965167ca819fd581f88ba8de97dda
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
let _initProto, _EnterProductionLineDecs, _LeaveProductionLineDecs, _EmitLineDecs, _ExecCSTMLInstructionLineDecs, _ExecSpamexInstructionLineDecs, _OutputLineDecs, _PunctuatorDecs, _AnyDecs;
import { i } from '@bablr/boot';
import { CoveredBy, Node, InjectFrom } from '@bablr/helpers/decorators';
import * as productions from '@bablr/helpers/productions';
import * as CSTML from '@bablr/language-en-cstml';
import * as CSTMLInstruction from '@bablr/language-en-bablr-vm-instruction/cstml';
import * as SpamexInstruction from '@bablr/language-en-bablr-vm-instruction/spamex';
import * as Space from '@bablr/language-en-blank-space';
export const dependencies = {
  Space,
  CSTML,
  CSTMLInstruction,
  SpamexInstruction
};
export const canonicalURL = 'https://bablr.org/languages/core/en/bablr-cli-verbose-output';
export function* eatMatchTrivia() {
  if (yield i`match(/[ \t\n]/)`) {
    return yield i`eat(<#*Space:Space />)`;
  }
  return null;
}
export const grammar = class VerboseOutputGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Output"], [Node, 2, "ProductionName"], [_EnterProductionLineDecs, 2, "EnterProductionLine"], [_LeaveProductionLineDecs, 2, "LeaveProductionLine"], [_EmitLineDecs, 2, "EmitLine"], [_ExecCSTMLInstructionLineDecs, 2, "ExecCSTMLInstructionLine"], [_ExecSpamexInstructionLineDecs, 2, "ExecSpamexInstructionLine"], [_OutputLineDecs, 2, "OutputLine"], [Node, 2, "Identifier"], [_PunctuatorDecs, 2, "Punctuator"], [_AnyDecs, 2, "Any"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_EnterProductionLineDecs = [CoveredBy('Line'), Node], _LeaveProductionLineDecs = [CoveredBy('Line'), Node], _EmitLineDecs = [CoveredBy('Line'), Node], _ExecCSTMLInstructionLineDecs = [CoveredBy('Line'), Node], _ExecSpamexInstructionLineDecs = [CoveredBy('Line'), Node], _OutputLineDecs = [CoveredBy('Line'), Node], _PunctuatorDecs = [Node, InjectFrom(productions)], _AnyDecs = InjectFrom(productions), "Output")]() {
    while ((yield i`match(/./)`) && (yield i`eat(<Line /> 'lines[]')`));
  }
  *Line() {
    yield i`eat(<Any /> null [
      <ExecSpamexInstructionLine '>>>' />
      <ExecCSTMLInstructionLine '    >>>' />
      <EmitLine '<<<' />
      <EnterProductionLine '-->' />
      <LeaveProductionLine /[x<]--/ />
      <OutputLine />
    ])`;
  }
  *ProductionName() {
    yield i`eatMatch(<~*Punctuator '[' /> 'openBrace')`;
    yield i`eat(<*Identifier /> 'productionName')`;
    yield i`eatMatch(<~*Punctuator ']' /> 'closeBrace')`;
  }
  *EnterProductionLine() {
    yield i`eat(<~*Punctuator '-->' /> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<ProductionName />)`;
    yield i`eat(<~*Punctuator '\n' /> 'lineTerminatorToken')`;
  }
  *LeaveProductionLine() {
    yield i`eat(<~*Punctuator /[<x]--/ /> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<ProductionName />)`;
    yield i`eat(<~*Punctuator '\n' /> 'lineTerminatorToken')`;
  }
  *EmitLine() {
    yield i`eat(<~*Punctuator '<<<' /> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<CSTML:Token /> 'expression')`;
    yield i`eat(<~*Punctuator '\n' /> 'lineTerminatorToken')`;
  }
  *ExecCSTMLInstructionLine() {
    yield i`eat(<~*Punctuator '    >>>' /> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<CSTMLInstruction:Call /> 'instruction')`;
    yield i`eat(<~*Punctuator '\n' /> 'lineTerminatorToken')`;
  }
  *ExecSpamexInstructionLine() {
    yield i`eat(<~*Punctuator '>>>' /> 'sigilToken')`;
    yield* eatMatchTrivia();
    yield i`eat(<SpamexInstruction:Call /> 'instruction')`;
    yield i`eat(<~*Punctuator '\n' /> 'lineTerminatorToken')`;
  }
  *OutputLine() {
    yield* eatMatchTrivia();
    yield i`eat(<CSTML:Tag /> 'expression')`;
    yield i`eat(<~*Punctuator '\n' /> 'lineTerminatorToken')`;
  }
  *Identifier() {
    yield i`eat(/[a-zA-Z]+/)`;
  }
  *Punctuator() {}
  *Any() {}
};